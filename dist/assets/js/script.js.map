{"version":3,"sources":["lib.js","main.js","burger.js","WOW.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;ACHA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"script.js","sourcesContent":["function test(a, b) {\r\n    return a + b\r\n}\r\n","console.log(test(5, 2));\r\nconsole.log(test(2, 4));\r\nconsole.log(test(9, 1));\r\n","","function isIn(needle, haystack) {\n  return haystack.indexOf(needle) >= 0;\n}\n\nfunction extend(custom, defaults) {\n  for (const key in defaults) {\n    if (custom[key] == null) {\n      const value = defaults[key];\n      custom[key] = value;\n    }\n  }\n  return custom;\n}\n\nfunction isMobile(agent) {\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);\n}\n\nfunction createEvent(event, bubble = false, cancel = false, detail = null) {\n  let customEvent;\n  if (document.createEvent != null) { // W3C DOM\n    customEvent = document.createEvent('CustomEvent');\n    customEvent.initCustomEvent(event, bubble, cancel, detail);\n  } else if (document.createEventObject != null) { // IE DOM < 9\n    customEvent = document.createEventObject();\n    customEvent.eventType = event;\n  } else {\n    customEvent.eventName = event;\n  }\n\n  return customEvent;\n}\n\nfunction emitEvent(elem, event) {\n  if (elem.dispatchEvent != null) { // W3C DOM\n    elem.dispatchEvent(event);\n  } else if (event in (elem != null)) {\n    elem[event]();\n  } else if (`on${event}` in (elem != null)) {\n    elem[`on${event}`]();\n  }\n}\n\nfunction addEvent(elem, event, fn) {\n  if (elem.addEventListener != null) { // W3C DOM\n    elem.addEventListener(event, fn, false);\n  } else if (elem.attachEvent != null) { // IE DOM\n    elem.attachEvent(`on${event}`, fn);\n  } else { // fallback\n    elem[event] = fn;\n  }\n}\n\nfunction removeEvent(elem, event, fn) {\n  if (elem.removeEventListener != null) { // W3C DOM\n    elem.removeEventListener(event, fn, false);\n  } else if (elem.detachEvent != null) { // IE DOM\n    elem.detachEvent(`on${event}`, fn);\n  } else { // fallback\n    delete elem[event];\n  }\n}\n\nfunction getInnerHeight() {\n  if ('innerHeight' in window) {\n    return window.innerHeight;\n  }\n\n  return document.documentElement.clientHeight;\n}\n\n// Minimalistic WeakMap shim, just in case.\nconst WeakMap = window.WeakMap || window.MozWeakMap ||\nclass WeakMap {\n  constructor() {\n    this.keys = [];\n    this.values = [];\n  }\n\n  get(key) {\n    for (let i = 0; i < this.keys.length; i++) {\n      const item = this.keys[i];\n      if (item === key) {\n        return this.values[i];\n      }\n    }\n    return undefined;\n  }\n\n  set(key, value) {\n    for (let i = 0; i < this.keys.length; i++) {\n      const item = this.keys[i];\n      if (item === key) {\n        this.values[i] = value;\n        return this;\n      }\n    }\n    this.keys.push(key);\n    this.values.push(value);\n    return this;\n  }\n};\n\n// Dummy MutationObserver, to avoid raising exceptions.\nconst MutationObserver =\n  window.MutationObserver || window.WebkitMutationObserver ||\n  window.MozMutationObserver ||\n  class MutationObserver {\n    constructor() {\n      if (typeof console !== 'undefined' && console !== null) {\n        console.warn('MutationObserver is not supported by your browser.');\n        console.warn(\n          'WOW.js cannot detect dom mutations, please call .sync() after loading new content.'\n        );\n      }\n    }\n\n    static notSupported = true;\n\n    observe() {}\n  };\n\n// getComputedStyle shim, from http://stackoverflow.com/a/21797294\nconst getComputedStyle = window.getComputedStyle ||\nfunction getComputedStyle(el) {\n  const getComputedStyleRX = /(\\-([a-z]){1})/g;\n  return {\n    getPropertyValue(prop) {\n      if (prop === 'float') { prop = 'styleFloat'; }\n      if (getComputedStyleRX.test(prop)) {\n        prop.replace(getComputedStyleRX, (_, _char) => _char.toUpperCase());\n      }\n      const { currentStyle } = el;\n      return (currentStyle != null ? currentStyle[prop] : void 0) || null;\n    },\n  };\n};\n\nexport default class WOW {\n  defaults = {\n    boxClass: 'wow',\n    animateClass: 'animated',\n    offset: 0,\n    mobile: true,\n    live: true,\n    callback: null,\n    scrollContainer: null,\n    resetAnimation: true,\n  };\n\n  constructor(options = {}) {\n    this.start = this.start.bind(this);\n    this.resetAnimation = this.resetAnimation.bind(this);\n    this.scrollHandler = this.scrollHandler.bind(this);\n    this.scrollCallback = this.scrollCallback.bind(this);\n    this.scrolled = true;\n    this.config = extend(options, this.defaults);\n    if (options.scrollContainer != null) {\n      this.config.scrollContainer = document.querySelector(options.scrollContainer);\n    }\n  // Map of elements to animation names:\n    this.animationNameCache = new WeakMap();\n    this.wowEvent = createEvent(this.config.boxClass);\n  }\n\n  init() {\n    this.element = window.document.documentElement;\n    if (isIn(document.readyState, ['interactive', 'complete'])) {\n      this.start();\n    } else {\n      addEvent(document, 'DOMContentLoaded', this.start);\n    }\n    this.finished = [];\n  }\n\n  start() {\n    this.stopped = false;\n    this.boxes = [].slice.call(this.element.querySelectorAll(`.${this.config.boxClass}`));\n    this.all = this.boxes.slice(0);\n    if (this.boxes.length) {\n      if (this.disabled()) {\n        this.resetStyle();\n      } else {\n        for (let i = 0; i < this.boxes.length; i++) {\n          const box = this.boxes[i];\n          this.applyStyle(box, true);\n        }\n      }\n    }\n    if (!this.disabled()) {\n      addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\n      addEvent(window, 'resize', this.scrollHandler);\n      this.interval = setInterval(this.scrollCallback, 50);\n    }\n    if (this.config.live) {\n      const mut = new MutationObserver(records => {\n        for (let j = 0; j < records.length; j++) {\n          const record = records[j];\n          for (let k = 0; k < record.addedNodes.length; k++) {\n            const node = record.addedNodes[k];\n            this.doSync(node);\n          }\n        }\n        return undefined;\n      });\n      mut.observe(document.body, {\n        childList: true,\n        subtree: true,\n      });\n    }\n  }\n\n// unbind the scroll event\n  stop() {\n    this.stopped = true;\n    removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\n    removeEvent(window, 'resize', this.scrollHandler);\n    if (this.interval != null) {\n      clearInterval(this.interval);\n    }\n  }\n\n  sync() {\n    if (MutationObserver.notSupported) {\n      this.doSync(this.element);\n    }\n  }\n\n  doSync(element) {\n    if (typeof element === 'undefined' || element === null) { ({ element } = this); }\n    if (element.nodeType !== 1) { return; }\n    element = element.parentNode || element;\n    const iterable = element.querySelectorAll(`.${this.config.boxClass}`);\n    for (let i = 0; i < iterable.length; i++) {\n      const box = iterable[i];\n      if (!isIn(box, this.all)) {\n        this.boxes.push(box);\n        this.all.push(box);\n        if (this.stopped || this.disabled()) {\n          this.resetStyle();\n        } else {\n          this.applyStyle(box, true);\n        }\n        this.scrolled = true;\n      }\n    }\n  }\n\n// show box element\n  show(box) {\n    this.applyStyle(box);\n    box.className = `${box.className} ${this.config.animateClass}`;\n    if (this.config.callback != null) { this.config.callback(box); }\n    emitEvent(box, this.wowEvent);\n\n\n    if (this.config.resetAnimation) {\n      addEvent(box, 'animationend', this.resetAnimation);\n      addEvent(box, 'oanimationend', this.resetAnimation);\n      addEvent(box, 'webkitAnimationEnd', this.resetAnimation);\n      addEvent(box, 'MSAnimationEnd', this.resetAnimation);\n    }\n\n    return box;\n  }\n\n  applyStyle(box, hidden) {\n    const duration = box.getAttribute('data-wow-duration');\n    const delay = box.getAttribute('data-wow-delay');\n    const iteration = box.getAttribute('data-wow-iteration');\n\n    return this.animate(() => this.customStyle(box, hidden, duration, delay, iteration));\n  }\n\n  animate = (function animateFactory() {\n    if ('requestAnimationFrame' in window) {\n      return callback => window.requestAnimationFrame(callback);\n    }\n    return callback => callback();\n  }());\n\n  resetStyle() {\n    for (let i = 0; i < this.boxes.length; i++) {\n      const box = this.boxes[i];\n      box.style.visibility = 'visible';\n    }\n    return undefined;\n  }\n\n  resetAnimation(event) {\n    if (event.type.toLowerCase().indexOf('animationend') >= 0) {\n      const target = event.target || event.srcElement;\n      target.className = target.className.replace(this.config.animateClass, '').trim();\n    }\n  }\n\n  customStyle(box, hidden, duration, delay, iteration) {\n    if (hidden) { this.cacheAnimationName(box); }\n    box.style.visibility = hidden ? 'hidden' : 'visible';\n\n    if (duration) { this.vendorSet(box.style, { animationDuration: duration }); }\n    if (delay) { this.vendorSet(box.style, { animationDelay: delay }); }\n    if (iteration) { this.vendorSet(box.style, { animationIterationCount: iteration }); }\n    this.vendorSet(box.style, { animationName: hidden ? 'none' : this.cachedAnimationName(box) });\n\n    return box;\n  }\n\n  vendors = ['moz', 'webkit'];\n  vendorSet(elem, properties) {\n    for (const name in properties) {\n      if (properties.hasOwnProperty(name)) {\n        const value = properties[name];\n        elem[`${name}`] = value;\n        for (let i = 0; i < this.vendors.length; i++) {\n          const vendor = this.vendors[i];\n          elem[`${vendor}${name.charAt(0).toUpperCase()}${name.substr(1)}`] = value;\n        }\n      }\n    }\n  }\n  vendorCSS(elem, property) {\n    const style = getComputedStyle(elem);\n    let result = style.getPropertyCSSValue(property);\n    for (let i = 0; i < this.vendors.length; i++) {\n      const vendor = this.vendors[i];\n      result = result || style.getPropertyCSSValue(`-${vendor}-${property}`);\n    }\n    return result;\n  }\n\n  animationName(box) {\n    let aName;\n    try {\n      aName = this.vendorCSS(box, 'animation-name').cssText;\n    } catch (error) { // Opera, fall back to plain property value\n      aName = getComputedStyle(box).getPropertyValue('animation-name');\n    }\n\n    if (aName === 'none') {\n      return '';  // SVG/Firefox, unable to get animation name?\n    }\n\n    return aName;\n  }\n\n  cacheAnimationName(box) {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=921834\n  // box.dataset is not supported for SVG elements in Firefox\n    return this.animationNameCache.set(box, this.animationName(box));\n  }\n  cachedAnimationName(box) {\n    return this.animationNameCache.get(box);\n  }\n\n  // fast window.scroll callback\n  scrollHandler() {\n    this.scrolled = true;\n  }\n\n  scrollCallback() {\n    if (this.scrolled) {\n      this.scrolled = false;\n      const results = [];\n      for (let i = 0; i < this.boxes.length; i++) {\n        const box = this.boxes[i];\n        if (box) {\n          if (this.isVisible(box)) {\n            this.show(box);\n            continue;\n          }\n          results.push(box);\n        }\n      }\n      this.boxes = results;\n      if (!this.boxes.length && !this.config.live) {\n        this.stop();\n      }\n    }\n  }\n\n\n  // Calculate element offset top\n  offsetTop(element) {\n    // SVG elements don't have an offsetTop in Firefox.\n    // This will use their nearest parent that has an offsetTop.\n    // Also, using ('offsetTop' of element) causes an exception in Firefox.\n    while (element.offsetTop === undefined) {\n      element = element.parentNode;\n    }\n    let top = element.offsetTop;\n    while (element.offsetParent) {\n      element = element.offsetParent;\n      top += element.offsetTop;\n    }\n    return top;\n  }\n\n// check if box is visible\n  isVisible(box) {\n    const offset = box.getAttribute('data-wow-offset') || this.config.offset;\n    const viewTop = (\n      this.config.scrollContainer && this.config.scrollContainer.scrollTop\n    ) || window.pageYOffset;\n    const viewBottom =\n      viewTop + Math.min(this.element.clientHeight, getInnerHeight()) - offset;\n    const top = this.offsetTop(box);\n    const bottom = top + box.clientHeight;\n\n    return top <= viewBottom && bottom >= viewTop;\n  }\n\n  disabled() {\n    return !this.config.mobile && isMobile(navigator.userAgent);\n  }\n}\n"]}